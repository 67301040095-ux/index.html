<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>H Layout Curved Pipe</title>
<style>
body { margin:0; overflow:hidden; background:#1e2228; }
button{
  position:fixed;
  top:20px;
  left:20px;
  padding:10px 20px;
  font-size:16px;
  z-index:10;
}
</style>
</head>
<body>

<button onclick="startSystem()">START SYSTEM</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>

<script>

// ===== SCENE =====
const scene = new THREE.Scene();

// ===== RENDERER =====
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// ===== CAMERA =====
const camera = new THREE.PerspectiveCamera(
60,
window.innerWidth/window.innerHeight,
0.1,
3000
);
camera.position.set(0,300,700);

// ===== CONTROLS =====
const controls = new THREE.OrbitControls(camera,renderer.domElement);
controls.target.set(0,0,-100);
controls.enableDamping = true;
controls.update();

// ===== LIGHT =====
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(300,400,200);
light.castShadow = true;
scene.add(light);

// ===== GROUND =====
const ground = new THREE.Mesh(
new THREE.PlaneGeometry(1000,800),
new THREE.MeshStandardMaterial({color:0xf0f0f0})
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// ===== POSITION =====
const CT  = new THREE.Vector3(-250,0,-200);
const AHU = new THREE.Vector3(250,0,-200);
const CH  = new THREE.Vector3(0,0,-100);
const CDP = new THREE.Vector3(-250,0,0);
const CHP = new THREE.Vector3(250,0,0);

// ===== CREATE BOX =====
function createBox(pos,color){
const mesh = new THREE.Mesh(
new THREE.BoxGeometry(80,80,80),
new THREE.MeshStandardMaterial({color:color})
);
mesh.position.copy(pos);
mesh.position.y = 40;
mesh.castShadow = true;
mesh.receiveShadow = true;
scene.add(mesh);
}
createBox(CT,0xaaaaaa);
createBox(AHU,0xddddcc);
createBox(CH,0xcccccc);
createBox(CDP,0x000000);
createBox(CHP,0x000000);

// ===== PIPE FUNCTION (90Â° CURVE) =====
function createPipe(start, mid, end, color){

const curve = new THREE.CatmullRomCurve3([
new THREE.Vector3(start.x,15,start.z),
new THREE.Vector3(mid.x,15,mid.z),
new THREE.Vector3(end.x,15,end.z)
]);

const geometry = new THREE.TubeGeometry(curve,50,5,16,false);
const material = new THREE.MeshStandardMaterial({color:0x666666});
const pipe = new THREE.Mesh(geometry,material);
scene.add(pipe);

return curve;
}

// ===== CREATE CURVED PATHS =====
const curve1 = createPipe(CT, new THREE.Vector3(CT.x,-0,-100), CH);
const curve2 = createPipe(CH, new THREE.Vector3(AHU.x,-0,-100), AHU);
const curve3 = createPipe(CDP,new THREE.Vector3(CDP.x,0,-100), CH);
const curve4 = createPipe(CH,new THREE.Vector3(CHP.x,0,-100), CHP);

// ===== FLOW BALLS =====
function createFlow(curve,color,count){

const balls = [];

for(let i=0;i<count;i++){
const ball = new THREE.Mesh(
new THREE.SphereGeometry(6,32,32),
new THREE.MeshStandardMaterial({
color:color,
emissive:color,
emissiveIntensity:1
})
);
scene.add(ball);

balls.push({
mesh:ball,
offset:i*(1/count)
});
}

return function(progress){

balls.forEach(obj=>{
let t = progress - obj.offset;
if(t < 0) t = 0;
if(t > 1) t = 1;

const point = curve.getPoint(t);
obj.mesh.position.copy(point);
});

}
}

const flow1 = createFlow(curve1,0xffff00,5);
const flow2 = createFlow(curve2,0x00ff00,5);
const flow3 = createFlow(curve3,0xffff00,5);
const flow4 = createFlow(curve4,0x00ff00,5);

let progress = 0;
let running = false;

function startSystem(){
running = true;
progress = 0;
}

function animate(){
requestAnimationFrame(animate);

if(running){
progress += 0.003;
if(progress > 1) progress = 1;

flow1(progress);
flow2(progress);
flow3(progress);
flow4(progress);
}

controls.update();
renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
camera.aspect = window.innerWidth/window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
